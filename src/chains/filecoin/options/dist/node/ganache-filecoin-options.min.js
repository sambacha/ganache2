(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("keccak"));
	else if(typeof define === 'function' && define.amd)
		define(["keccak"], factory);
	else if(typeof exports === 'object')
		exports["Filecoin-flavored Ganache Options"] = factory(require("keccak"));
	else
		root["Filecoin-flavored Ganache Options"] = factory(root["keccak"]);
})(global, function(__WEBPACK_EXTERNAL_MODULE__8112__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(4832);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(8652);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(801);

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(2030);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(3618);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(9049);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(1971);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ 4832:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 9049:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 8652:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 3618:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ 2030:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ 801:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 1971:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(6417);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ 1416:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

/*!
 * @ganache/filecoin-options
 *
 * @author Tim Coulter
 * @license MIT
 */
__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = void 0;
const src_1 = __webpack_require__(3465);
var src_2 = __webpack_require__(3465);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return src_2.FilecoinInternalOptions; } });
__webpack_unused_export__ = ({ enumerable: true, get: function () { return src_2.FilecoinOptionsConfig; } });
__webpack_unused_export__ = ({ enumerable: true, get: function () { return src_2.FilecoinProviderOptions; } });
__webpack_unused_export__ = ({ enumerable: true, get: function () { return src_2.FilecoinDefaults; } });
__webpack_unused_export__ = ({ enumerable: true, get: function () { return src_2.FilecoinLegacyProviderOptions; } });
exports.default = {
    FilecoinDefaults: src_1.FilecoinDefaults,
    FilecoinOptionsConfig: src_1.FilecoinOptionsConfig
};


/***/ }),

/***/ 9603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChainOptions = void 0;
const helpers_1 = __webpack_require__(2655);
exports.ChainOptions = {
    ipfsHost: {
        normalize: helpers_1.normalize,
        cliDescription: "The IPFS simulator host name/address to listen on.",
        default: () => "127.0.0.1",
        cliType: "string"
    },
    ipfsPort: {
        normalize: helpers_1.normalize,
        cliDescription: "The IPFS simulator port.",
        default: () => 5001,
        cliType: "number"
    },
    asyncRequestProcessing: {
        normalize: helpers_1.normalize,
        cliDescription: "When set to `false` only one request will be processed at a time.",
        default: () => true,
        cliType: "boolean"
    }
};


/***/ }),

/***/ 5185:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseOptions = void 0;
const helpers_1 = __webpack_require__(2655);
exports.DatabaseOptions = {
    db: {
        normalize: helpers_1.normalize,
        cliDescription: "Specify an alternative database instance, like MemDOWN",
        disableInCLI: true,
        conflicts: ["dbPath"]
    },
    dbPath: {
        normalize: helpers_1.normalize,
        cliDescription: "Specify a path to a directory to save the chain database.",
        cliAliases: ["db"],
        cliType: "string",
        conflicts: ["db"]
    }
};


/***/ }),

/***/ 2655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalize = void 0;
const normalize = (rawInput) => rawInput;
exports.normalize = normalize;


/***/ }),

/***/ 3465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilecoinOptionsConfig = exports.FilecoinDefaults = void 0;
const chain_options_1 = __webpack_require__(9603);
const database_options_1 = __webpack_require__(5185);
const logging_options_1 = __webpack_require__(1740);
const miner_options_1 = __webpack_require__(944);
const wallet_options_1 = __webpack_require__(8672);
const options_1 = __webpack_require__(8991);
exports.FilecoinDefaults = {
    chain: chain_options_1.ChainOptions,
    database: database_options_1.DatabaseOptions,
    logging: logging_options_1.LoggingOptions,
    miner: miner_options_1.MinerOptions,
    wallet: wallet_options_1.WalletOptions
};
exports.FilecoinOptionsConfig = new options_1.OptionsConfig(exports.FilecoinDefaults);


/***/ }),

/***/ 1740:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggingOptions = void 0;
const helpers_1 = __webpack_require__(2655);
const logger = { log: console.log };
exports.LoggingOptions = {
    logger: {
        normalize: helpers_1.normalize,
        cliDescription: "An object, like `console`, that implements a `log` function.",
        disableInCLI: true,
        default: () => logger
    }
};


/***/ }),

/***/ 944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MinerOptions = void 0;
const helpers_1 = __webpack_require__(2655);
exports.MinerOptions = {
    blockTime: {
        normalize: value => Math.max(0, value),
        cliDescription: 'Sets the `blockTime` in seconds for automatic mining. A `blockTime` of `0` or a negative number enables "instamine mode", where new executable transactions will be mined instantly.',
        default: () => 0,
        cliType: "number"
    },
    mine: {
        normalize: helpers_1.normalize,
        cliDescription: "Enable mining. Set to `false` to pause the miner.",
        default: () => true,
        cliType: "boolean"
    }
};


/***/ }),

/***/ 8672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalletOptions = void 0;
const helpers_1 = __webpack_require__(2655);
const seedrandom_1 = __importDefault(__webpack_require__(6377));
const options_1 = __webpack_require__(8991);
const unseededRng = seedrandom_1.default();
const randomAlphaNumericString = (() => {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const alphabetLength = alphabet.length;
    return (length, rng) => {
        let text = "";
        for (let i = 0; i < length; i++) {
            text += alphabet[(rng() * alphabetLength) | 0];
        }
        return text;
    };
})();
exports.WalletOptions = {
    totalAccounts: {
        normalize: helpers_1.normalize,
        cliDescription: "Number of accounts to generate at startup.",
        default: () => 10,
        cliAliases: ["a"],
        cliType: "number"
    },
    deterministic: {
        normalize: helpers_1.normalize,
        cliDescription: "Use pre-defined, deterministic seed.",
        default: () => false,
        cliAliases: ["d"],
        cliType: "boolean",
        conflicts: ["seed"]
    },
    seed: {
        normalize: helpers_1.normalize,
        cliDescription: "Seed to use to generate a mnemonic.",
        // The order of the options matter here! `wallet.deterministic`
        // needs to be prior to `wallet.seed` for `config.deterministic`
        // below to be set correctly
        default: config => config.deterministic === true
            ? options_1.DeterministicSeedPhrase
            : randomAlphaNumericString(10, unseededRng),
        cliAliases: ["s"],
        cliType: "string",
        conflicts: ["deterministic"]
    },
    defaultBalance: {
        normalize: helpers_1.normalize,
        cliDescription: "The default account balance, specified in FIL.",
        default: () => 100,
        cliAliases: ["b"],
        cliType: "number"
    }
};


/***/ }),

/***/ 8991:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(6598), exports);
__exportStar(__webpack_require__(511), exports);
__exportStar(__webpack_require__(1731), exports);
__exportStar(__webpack_require__(1078), exports);
__exportStar(__webpack_require__(6089), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6598:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=base.js.map

/***/ }),

/***/ 6089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeterministicSeedPhrase = void 0;
// Don't change! We need maintain original determinism since the beginning
exports.DeterministicSeedPhrase = "TestRPC is awesome!";
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 1078:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _defaults, _namespaces;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OptionsConfig = void 0;
const utils_1 = __webpack_require__(3246);
const checkForConflicts = (name, namespace, suppliedOptions, conflicts) => {
    if (!conflicts)
        return;
    for (const conflict of conflicts) {
        if (suppliedOptions.has(conflict)) {
            throw new Error(`Values for both "${namespace}.${name}" and ` +
                `"${namespace}.${conflict}" cannot ` +
                `be specified; they are mutually exclusive.`);
        }
    }
};
function fill(defaults, options, target, namespace) {
    const def = defaults[namespace];
    const config = (target[namespace] = target[namespace] || {});
    const flavor = options.flavor;
    const suppliedOptions = new Set();
    const keys = Object.keys(def);
    if (utils_1.hasOwn(options, namespace)) {
        const namespaceOptions = options[namespace];
        for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            const propDefinition = def[key];
            let value = namespaceOptions[key];
            if (value !== undefined) {
                checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                const normalized = propDefinition.normalize(namespaceOptions[key]);
                config[key] = normalized;
                suppliedOptions.add(key);
            }
            else {
                const legacyName = propDefinition.legacyName || key;
                value = options[legacyName];
                if (value !== undefined) {
                    checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                    const normalized = propDefinition.normalize(value);
                    config[key] = normalized;
                    suppliedOptions.add(key);
                }
                else if (utils_1.hasOwn(propDefinition, "default")) {
                    config[key] = propDefinition.default(config, flavor);
                }
            }
        }
    }
    else {
        for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            const propDefinition = def[key];
            const legacyName = propDefinition.legacyName || key;
            const value = options[legacyName];
            if (value !== undefined) {
                checkForConflicts(key, namespace, suppliedOptions, propDefinition.conflicts);
                const normalized = propDefinition.normalize(value);
                config[key] = normalized;
                suppliedOptions.add(key);
            }
            else if (utils_1.hasOwn(propDefinition, "default")) {
                config[key] = propDefinition.default(config, flavor);
            }
        }
    }
}
class OptionsConfig {
    constructor(defaults) {
        _defaults.set(this, void 0);
        _namespaces.set(this, void 0);
        __classPrivateFieldSet(this, _defaults, defaults);
        __classPrivateFieldSet(this, _namespaces, Object.keys(defaults));
    }
    normalize(options) {
        const defaults = __classPrivateFieldGet(this, _defaults);
        const out = {};
        __classPrivateFieldGet(this, _namespaces).forEach(namespace => {
            fill(defaults, options, out, namespace);
        });
        return out;
    }
}
exports.OptionsConfig = OptionsConfig;
_defaults = new WeakMap(), _namespaces = new WeakMap();
//# sourceMappingURL=create.js.map

/***/ }),

/***/ 1731:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//#endregion Definition helpers
//# sourceMappingURL=definition.js.map

/***/ }),

/***/ 511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//#endregion
//# sourceMappingURL=exclusive.js.map

/***/ }),

/***/ 3246:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiEvent = exports.JsonRpcErrorCode = exports.makeResponse = exports.makeRequest = exports.makeError = void 0;
__exportStar(__webpack_require__(3972), exports);
__exportStar(__webpack_require__(2875), exports);
__exportStar(__webpack_require__(6554), exports);
__exportStar(__webpack_require__(5088), exports);
__exportStar(__webpack_require__(2883), exports);
var jsonrpc_1 = __webpack_require__(4469);
Object.defineProperty(exports, "makeError", ({ enumerable: true, get: function () { return jsonrpc_1.makeError; } }));
Object.defineProperty(exports, "makeRequest", ({ enumerable: true, get: function () { return jsonrpc_1.makeRequest; } }));
Object.defineProperty(exports, "makeResponse", ({ enumerable: true, get: function () { return jsonrpc_1.makeResponse; } }));
Object.defineProperty(exports, "JsonRpcErrorCode", ({ enumerable: true, get: function () { return jsonrpc_1.JsonRpcErrorCode; } }));
var promievent_1 = __webpack_require__(2744);
Object.defineProperty(exports, "PromiEvent", ({ enumerable: true, get: function () { return __importDefault(promievent_1).default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4327:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBigIntBE = exports.toBufferBE = void 0;
var bigint_buffer_1 = __webpack_require__(7655);
Object.defineProperty(exports, "toBufferBE", ({ enumerable: true, get: function () { return bigint_buffer_1.toBufferBE; } }));
Object.defineProperty(exports, "toBigIntBE", ({ enumerable: true, get: function () { return bigint_buffer_1.toBigIntBE; } }));
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 9280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseJsonRpcType = exports.toBuffers = exports.toStrings = exports.bufCache = exports.strCache = void 0;
const utils_1 = __webpack_require__(2875);
const utils_2 = __webpack_require__(2875);
const constants_1 = __webpack_require__(9007);
exports.strCache = new WeakMap();
exports.bufCache = new WeakMap();
exports.toStrings = new WeakMap();
exports.toBuffers = new WeakMap();
const inspect = Symbol.for("nodejs.util.inspect.custom");
class BaseJsonRpcType {
    constructor(value) {
        const self = this;
        if (Buffer.isBuffer(value)) {
            exports.toStrings.set(this, () => value.toString("hex"));
            exports.bufCache.set(this, value);
            self[Symbol.toStringTag] = "Buffer";
        }
        else {
            const type = typeof value;
            switch (type) {
                case "number":
                    if (value % 1 !== 0) {
                        throw new Error("`Cannot wrap a decimal value as a json-rpc type`");
                    }
                    exports.toStrings.set(this, () => value.toString(16));
                    exports.toBuffers.set(this, () => value === 0 ? constants_1.BUFFER_EMPTY : utils_2.uintToBuffer(value));
                    break;
                case "bigint":
                    exports.toStrings.set(this, () => value.toString(16));
                    exports.toBuffers.set(this, () => value === 0n ? constants_1.BUFFER_EMPTY : utils_1.bigIntToBuffer(value));
                    break;
                case "string": {
                    // handle hex-encoded string
                    if (value.indexOf("0x") === 0) {
                        exports.strCache.set(this, value.toLowerCase());
                        exports.toBuffers.set(this, () => {
                            let fixedValue = value.slice(2);
                            if (fixedValue.length % 2 === 1) {
                                fixedValue = "0" + fixedValue;
                            }
                            return Buffer.from(fixedValue, "hex");
                        });
                    }
                    else {
                        throw new Error(`cannot convert string value "${value}" into type \`${this.constructor.name}\`; strings must be hex-encoded and prefixed with "0x".`);
                    }
                    break;
                }
                default:
                    // handle undefined/null
                    if (value == null) {
                        // This is a weird thing that returns undefined/null for a call
                        // to toString().
                        this.toString = () => value;
                        exports.bufCache.set(this, constants_1.BUFFER_EMPTY);
                        break;
                    }
                    throw new Error(`Cannot wrap a "${type}" as a json-rpc type`);
            }
            self[Symbol.toStringTag] = type;
        }
        this.value = value;
    }
    // used to make console.log debugging a little easier
    [inspect](_depth, _options) {
        return this.value;
    }
    toString() {
        let str = exports.strCache.get(this);
        if (str === void 0) {
            str = "0x" + exports.toStrings.get(this)();
            exports.strCache.set(this, str);
        }
        return str;
    }
    toBuffer() {
        let buf = exports.bufCache.get(this);
        if (buf === void 0) {
            buf = exports.toBuffers.get(this)();
            exports.bufCache.set(this, buf);
        }
        return buf;
    }
    valueOf() {
        return this.value;
    }
    toJSON() {
        return this.toString();
    }
    isNull() {
        return this.value == null;
    }
}
exports.BaseJsonRpcType = BaseJsonRpcType;
//# sourceMappingURL=json-rpc-base-types.js.map

/***/ }),

/***/ 2883:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Data = void 0;
const json_rpc_base_types_1 = __webpack_require__(9280);
const json_rpc_base_types_2 = __webpack_require__(9280);
function validateByteLength(byteLength) {
    if (typeof byteLength !== "number" || byteLength < 0) {
        throw new Error(`byteLength must be a number greater than 0`);
    }
}
const byteLengths = new WeakMap();
class Data extends json_rpc_base_types_1.BaseJsonRpcType {
    constructor(value, byteLength) {
        if (typeof value === "bigint") {
            throw new Error(`Cannot create a ${typeof value} as a Data`);
        }
        super(value);
        if (byteLength !== void 0) {
            validateByteLength(byteLength);
            byteLengths.set(this, byteLength | 0);
        }
    }
    toString(byteLength) {
        const str = json_rpc_base_types_2.strCache.get(this);
        if (str !== void 0) {
            return str;
        }
        else {
            let str = json_rpc_base_types_2.toStrings.get(this)();
            let length = str.length;
            if (length % 2 === 1) {
                length++;
                str = `0${str}`;
            }
            if (byteLength !== void 0) {
                validateByteLength(byteLength);
            }
            else {
                byteLength = byteLengths.get(this);
            }
            if (byteLength !== void 0) {
                const strLength = byteLength * 2;
                const padBy = strLength - length;
                if (padBy < 0) {
                    // if our hex-encoded data is longer than it should be, truncate it:
                    str = str.slice(0, strLength);
                }
                else if (padBy > 0) {
                    // if our hex-encoded data is shorter than it should be, pad it:
                    str = "0".repeat(padBy) + str;
                }
            }
            return `0x${str}`;
        }
    }
    static from(value, byteLength) {
        return new Data(value, byteLength);
    }
}
exports.Data = Data;
//# sourceMappingURL=json-rpc-data.js.map

/***/ }),

/***/ 5088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Quantity = void 0;
const utils_1 = __webpack_require__(2875);
const json_rpc_base_types_1 = __webpack_require__(9280);
// TODO(perf): rewrite this stuff since it isn't really caching anything
class Quantity extends json_rpc_base_types_1.BaseJsonRpcType {
    constructor() {
        super(...arguments);
        this._nullable = false;
    }
    static from(value, nullable = false) {
        if (value instanceof Quantity)
            return value;
        const q = new Quantity(value);
        q._nullable = nullable;
        return q;
    }
    toString() {
        // TODO(perf): memoize this stuff
        if (Buffer.isBuffer(this.value)) {
            let val = this.value.toString("hex").replace(/^(?:0+(.+?))?$/, "$1");
            if (val === "") {
                if (this._nullable) {
                    return null;
                }
                // RPC Quantities must represent `0` as `0x0`
                return "0x0";
            }
            return `0x${val}`;
        }
        else if (this.value == null) {
            return "0x";
        }
        else {
            return super.toString();
        }
    }
    toBuffer() {
        // 0x0, 0x00, 0x000, etc should return BUFFER_EMPTY
        if (Buffer.isBuffer(this.value)) {
            // trim zeros from start
            let best = 0;
            for (best = 0; best < this.value.length; best++) {
                if (this.value[best] !== 0)
                    break;
            }
            if (best > 0) {
                return this.value.slice(best);
            }
            else {
                return this.value;
            }
        }
        else if (typeof this.value === "string") {
            let val = this.value.slice(2).replace(/^(?:0+(.+?))?$/, "$1");
            if (val === "" || val === "0") {
                return utils_1.BUFFER_EMPTY;
            }
        }
        else if (this.value === 0 || this.value === 0n) {
            return utils_1.BUFFER_EMPTY;
        }
        return super.toBuffer();
    }
    toBigInt() {
        const value = this.value;
        // TODO(perf): memoize this stuff
        if (Buffer.isBuffer(value)) {
            const bigInt = utils_1.bufferToBigInt(value);
            return bigInt == null ? (this._nullable ? null : 0n) : bigInt;
        }
        else {
            return value == null ? (this._nullable ? null : 0n) : BigInt(value);
        }
    }
    toNumber() {
        // TODO(perf): memoize this stuff
        return typeof this.value === "number"
            ? this.value
            : Number(this.toBigInt());
    }
    valueOf() {
        const value = this.value;
        if (value === null) {
            return value;
        }
        else if (value === undefined) {
            return value;
        }
        else {
            return this.toBigInt();
        }
    }
}
exports.Quantity = Quantity;
exports.default = Quantity;
//# sourceMappingURL=json-rpc-quantity.js.map

/***/ }),

/***/ 4469:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcErrorCode = exports.makeError = exports.makeResponse = exports.makeRequest = void 0;
const jsonrpc = "2.0";
const makeRequest = (json) => {
    return {
        id: json.id,
        jsonrpc,
        method: json.method,
        params: json.params
    };
};
exports.makeRequest = makeRequest;
const makeResponse = (id, result) => {
    return {
        id,
        jsonrpc,
        result
    };
};
exports.makeResponse = makeResponse;
const makeError = (id, error, result) => {
    // Error objects are weird, `message` isn't included in the property names,
    // so it is pulled out separately.
    const details = { message: error.message };
    Object.getOwnPropertyNames(error).forEach(name => {
        if (typeof name === "string") {
            details[name] = error[name];
        }
    });
    if (typeof details.code !== "number") {
        details.code = -32700; // JSON-RPC Parse error
    }
    if (result !== undefined) {
        return {
            id,
            jsonrpc,
            error: details,
            result
        };
    }
    else {
        return {
            id,
            jsonrpc,
            error: details
        };
    }
};
exports.makeError = makeError;
var JsonRpcErrorCode;
(function (JsonRpcErrorCode) {
    /**
     * Invalid JSON was received by the server.
     * An error occurred on the server while parsing the JSON text.
     */
    JsonRpcErrorCode[JsonRpcErrorCode["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    /**
     * The JSON sent is not a valid Request object.
     */
    JsonRpcErrorCode[JsonRpcErrorCode["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    /**
     * The method does not exist / is not available.
     */
    JsonRpcErrorCode[JsonRpcErrorCode["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    /**
     * Invalid method parameter(s).
     */
    JsonRpcErrorCode[JsonRpcErrorCode["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    /**
     * Internal JSON-RPC error.
     */
    JsonRpcErrorCode[JsonRpcErrorCode["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    /**
     * Missing or invalid parameters
     */
    JsonRpcErrorCode[JsonRpcErrorCode["INVALID_INPUT"] = -32000] = "INVALID_INPUT";
    /**
     * Transaction creation failed
     */
    JsonRpcErrorCode[JsonRpcErrorCode["TRANSACTION_REJECTED"] = -32003] = "TRANSACTION_REJECTED";
    /**
     * 	Method is not implemented
     */
    JsonRpcErrorCode[JsonRpcErrorCode["METHOD_NOT_SUPPORTED"] = -32004] = "METHOD_NOT_SUPPORTED";
    /**
     * 	Request exceeds defined limit
     */
    JsonRpcErrorCode[JsonRpcErrorCode["LIMIT_EXCEEDED"] = -32005] = "LIMIT_EXCEEDED";
    /**
     * Version of JSON-RPC protocol is not supported
     */
    JsonRpcErrorCode[JsonRpcErrorCode["JSON_RPC_VERSION_NOT_SUPPORTED"] = -32006] = "JSON_RPC_VERSION_NOT_SUPPORTED";
})(JsonRpcErrorCode = exports.JsonRpcErrorCode || (exports.JsonRpcErrorCode = {}));
//# sourceMappingURL=jsonrpc.js.map

/***/ }),

/***/ 2744:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var PromiEvent_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const emittery_1 = __importDefault(__webpack_require__(6462));
const emitteryMethods = [
    "clearListeners",
    "once",
    "on",
    "emit",
    "onAny"
];
let PromiEvent = PromiEvent_1 = class PromiEvent extends Promise {
    constructor(executor) {
        super(executor);
        /**
         * Used to immediately clear all event listeners on the instance and prevent
         * any additional binding or emission from the Emitter.
         *
         * Once disposed no listeners can be bound to this emitter.
         *
         * Note: `dispose` is pre-bound to the `this`, making it possible to pass the
         * method around detached from it's context.
         */
        this.dispose = () => {
            if (!this.clearListeners)
                throw new Error("PromiEvent already disposed");
            this.clearListeners();
            // Ensure that once disposed no listeners can be bound to this emitter.
            const fn = () => {
                throw new Error("PromiEvent bound after dispose");
            };
            emitteryMethods
                .filter(m => m !== "emit")
                .forEach(methodName => {
                Object.defineProperty(this, methodName, {
                    enumerable: false,
                    value: fn
                });
            });
        };
    }
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A PromiEvent for the completion of the callback.
     */
    catch(onrejected) {
        const prom = new PromiEvent_1((resolve, reject) => {
            this.onAny((eventName, eventData) => {
                return prom.emit(eventName, eventData);
            });
            const p = super.catch(onrejected);
            p.then(resolve, reject);
        });
        return prom;
    }
    static resolve(value) {
        return new PromiEvent_1(resolve => {
            resolve(value);
        });
    }
};
PromiEvent = PromiEvent_1 = __decorate([
    emittery_1.default.mixin(Symbol.for("emittery"), emitteryMethods)
], PromiEvent);
exports.default = PromiEvent;
//# sourceMappingURL=promievent.js.map

/***/ }),

/***/ 6554:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=subscription.js.map

/***/ }),

/***/ 3897:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Base implementation for an API.
 * All properties must be `async` callable or return a `Promise`
 */
class ApiBase {
}
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 5677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=connector.js.map

/***/ }),

/***/ 3972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(5677), exports);
__exportStar(__webpack_require__(2925), exports);
__exportStar(__webpack_require__(3897), exports);
function b() { }
function g(t) {
    return 123;
}
g({});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2925:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=provider.js.map

/***/ }),

/***/ 6153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigIntToBuffer = void 0;
const common_1 = __webpack_require__(4327);
const uint_to_buffer_1 = __webpack_require__(614);
const allocUnsafe = Buffer.allocUnsafe;
let _bigIntToBuffer;
/**
 * Returns the number of bytes contained in this given `value`.
 * @param value
 */
function bigIntByteLength(value) {
    let length = 1;
    while ((value >>= 8n))
        length++;
    return length;
}
const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
try {
    // force fallback if only `toBufferBE` is missing (this can happen if toBufferBE isn't polyfilled for the browser,
    // which, at the time of this writing... it isn't)
    if (!common_1.toBufferBE)
        throw new Error("Missing function `toBufferBE`!");
    _bigIntToBuffer = (value) => {
        if (value <= MAX_SAFE_INTEGER) {
            return uint_to_buffer_1.uintToBuffer(Number(value));
        }
        else {
            const size = bigIntByteLength(value);
            return common_1.toBufferBE(value, size);
        }
    };
}
catch (e) {
    _bigIntToBuffer = (value) => {
        if (value <= MAX_SAFE_INTEGER) {
            // if this value can be handled as a JS number safely, convert it that way
            return uint_to_buffer_1.uintToBuffer(Number(value));
        }
        else {
            let length = bigIntByteLength(value);
            const buf = allocUnsafe(length);
            // process 1 byte at a time
            do {
                // truncate to right-most 32 bits and assign to buffer position `length`
                buf[--length] = Number(value & 0xffffffffn);
                // shift right-most byte off since we've used it
                value >>= 8n;
            } while (length);
            return buf;
        }
    };
}
/**
 * Converts a bigint to a Buffer (Big Endian)
 */
exports.bigIntToBuffer = _bigIntToBuffer;
//# sourceMappingURL=bigint-to-buffer.js.map

/***/ }),

/***/ 6802:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bufferToBigInt = void 0;
const bigint_buffer_1 = __webpack_require__(7655);
/**
 * note: this doesn't handle negative values
 * @param value Buffer representation of a bigint, most-significant bit first (Big-endian)
 */
function bufferToBigInt(value) {
    // Parsed as BE.
    // This doesn't handle negative values. We may need to add logic to handle
    // it because it is possible values returned from the VM could be negative
    // and stored in a buffer.
    const length = value.byteLength;
    if (length === 0) {
        return null;
    }
    // Buffers that are 6 bytes or less can be converted with built-in methods
    if (length <= 6) {
        return BigInt(value.readUIntBE(0, length));
    }
    let view;
    // Buffers that are 7 bytes need to be padded to 8 bytes
    if (length === 7) {
        const padded = new Uint8Array(8);
        // set byte 0 to 0, and bytes 1-8 to the value's 7 bytes:
        padded.set(value, 1);
        view = new DataView(padded.buffer);
    }
    else if (length === 8) {
        view = new DataView(value.buffer, value.byteOffset, length);
    }
    else {
        // TODO: toBigIntBE is a native lib with no pure JS fallback yet.
        return bigint_buffer_1.toBigIntBE(value);
    }
    return view.getBigUint64(0);
}
exports.bufferToBigInt = bufferToBigInt;
//# sourceMappingURL=buffer-to-bigint.js.map

/***/ }),

/***/ 3781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bufferToMinHexKey = void 0;
let stringify;
if (typeof Buffer.prototype.latin1Slice === "function") {
    stringify = (buffer, start, end) => {
        // this is just `buffer.toString("hex")`, but it skips a bunch of checks
        // that don't apply because our `start` and `end` just can't be out of
        // bounds.
        return buffer.hexSlice(start, end);
    };
}
else {
    stringify = (buffer, start, end) => {
        return buffer.slice(start, end).toString("hex");
    };
}
/**
 * Trims leading 0s from a buffer and returns a key representing the buffer's
 * trimmed value (`Buffer.from([0, 0, 12, 0])` => `1200`).
 *
 * @param buffer
 */
function bufferToMinHexKey(buffer) {
    for (let i = 0, length = buffer.byteLength; i < length; i++) {
        const value = buffer[i];
        // once we find a non-zero value take the rest of the buffer as the key
        if (value !== 0) {
            if (i + 1 === length) {
                // use a lookup table for single character lookups
                return HEX_MAP[value];
            }
            else {
                return stringify(buffer, i, length);
            }
        }
    }
    return "";
}
exports.bufferToMinHexKey = bufferToMinHexKey;
const HEX_MAP = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
];
//# sourceMappingURL=buffer-to-key.js.map

/***/ }),

/***/ 9007:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KNOWN_CHAINIDS = exports.WEI = exports.RPCQUANTITY_ONE = exports.RPCQUANTITY_ZERO = exports.RPCQUANTITY_EMPTY = exports.DATA_EMPTY = exports.BUFFER_8_ZERO = exports.BUFFER_32_ZERO = exports.BUFFER_ZERO = exports.BUFFER_EMPTY = exports.ACCOUNT_ZERO = exports.BUFFER_256_ZERO = void 0;
const json_rpc_data_1 = __webpack_require__(2883);
const json_rpc_quantity_1 = __webpack_require__(5088);
exports.BUFFER_256_ZERO = Buffer.allocUnsafe(256).fill(0);
exports.ACCOUNT_ZERO = exports.BUFFER_256_ZERO.slice(0, 20);
exports.BUFFER_EMPTY = Buffer.allocUnsafe(0);
exports.BUFFER_ZERO = exports.BUFFER_256_ZERO.slice(0, 1);
exports.BUFFER_32_ZERO = exports.BUFFER_256_ZERO.slice(0, 32);
exports.BUFFER_8_ZERO = exports.BUFFER_256_ZERO.slice(0, 8);
exports.DATA_EMPTY = json_rpc_data_1.Data.from(exports.BUFFER_EMPTY);
exports.RPCQUANTITY_EMPTY = json_rpc_quantity_1.Quantity.from(exports.BUFFER_EMPTY, true);
exports.RPCQUANTITY_ZERO = json_rpc_quantity_1.Quantity.from(exports.BUFFER_ZERO);
exports.RPCQUANTITY_ONE = json_rpc_quantity_1.Quantity.from(1n);
exports.WEI = 1000000000000000000n;
exports.KNOWN_CHAINIDS = new Set([1, 3, 4, 5, 42]);
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 1131:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _requestCoordinator;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Executor = void 0;
const has_own_1 = __webpack_require__(149);
class Executor {
    /**
     * The Executor handles execution of methods on the given API
     */
    constructor(requestCoordinator) {
        _requestCoordinator.set(this, void 0);
        __classPrivateFieldSet(this, _requestCoordinator, requestCoordinator);
    }
    /**
     * Executes the method with the given methodName on the API
     * @param methodName The name of the JSON-RPC method to execute.
     * @param params The params to pass to the JSON-RPC method.
     */
    execute(api, methodName, params) {
        // The methodName is user-entered data and can be all sorts of weird hackery
        // Make sure we only accept what we expect to avoid headache and heartache
        if (typeof methodName === "string") {
            // Only allow executing our *own* methods. We allow:
            //  * functions added to the Instance by the class, e.g.,
            //      class SomeClass {
            //        method = () => {} // api.hasOwnProperty("method") === true
            //      }
            //  * Or by the class' prototype:
            //      class SomeClass {
            //        method(){} // api.__proto__.hasOwnProperty("method") === true
            //      }
            if ((has_own_1.hasOwn(api.__proto__, methodName) && methodName !== "constructor") ||
                has_own_1.hasOwn(api, methodName)) {
                // cast methodName from `KnownKeys<T> & string` back to KnownKeys<T> so our return type isn't weird.
                const fn = api[methodName];
                // just double check, in case a API breaks the rules and adds non-fns
                // to their API interface.
                if (typeof fn === "function") {
                    // queue up this method for actual execution:
                    return __classPrivateFieldGet(this, _requestCoordinator).queue(fn, api, params);
                }
            }
        }
        throw new Error(`The method ${methodName} does not exist/is not available`);
    }
}
exports.Executor = Executor;
_requestCoordinator = new WeakMap();
//# sourceMappingURL=executor.js.map

/***/ }),

/***/ 4092:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findInsertPosition = void 0;
/**
 * AKA `upper_bound`
 *
 * The elements are compared using `comp`. The elements in the range must
 * already be sorted according to this same criterion (`comp`), or at least
 * partitioned with respect to val.
 *
 * The function optimizes the number of comparisons performed by comparing
 * non-consecutive elements of the sorted range.
 *
 * The index into the `array` returned by this function will always be greater than
 * the index of the last-occurrence of `val`.
 *
 * On average, logarithmic in the distance of the length of the array: Performs
 * approximately `log2(N)+1` element comparisons (where `N` is this length).
 *
 * @param array
 * @param val Value of the upper bound to search for in the range.
 * @param comp A function that accepts two arguments (the first is always
 * `val`, and the second from the given `array`) and returns bool. The value
 * returned indicates whether the first argument is considered to go before the
 * second.
 *
 * @returns The index to the upper bound position for `val` in the range. If no
 * element in the range compares greater than `val`, the function returns
 * `array.length`.
 */
function findInsertPosition(array, val, comp) {
    // `count` tracks the number of elements that remain to be searched
    let count = array.length;
    // `insertPosition` tracks the best insert position for the element we know
    // about _so far_
    let insertPosition = 0;
    // `offset` tracks the start position of the elements that remain to be
    // searched
    let offset = 0;
    while (count > 0) {
        // find the middle element between `offset` and `count`
        const step = (count / 2) | 0; // ()`| 0` rounds towards 0)
        offset += step;
        // compare our val to the "middle element" (`array[offset]`)
        if (!comp(val, array[offset])) {
            // `val` should come _after_ the element at `array[offset]`.
            //  * update our `insertPosition` to the index immediately after
            //    `array[offset]`
            //  * shrink our search range
            // This narrows our search the elements to the right of `array[offset]`.
            insertPosition = ++offset;
            count -= step + 1;
        }
        else {
            // `val` should come before the element at `array[offset]`:
            // This narrows the search the elements to the left of `array[offset]`.
            count = step;
            offset = insertPosition;
        }
    }
    return insertPosition;
}
exports.findInsertPosition = findInsertPosition;
//# sourceMappingURL=find-insert-position.js.map

/***/ }),

/***/ 149:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasOwn = void 0;
const _hasOwn = {}.hasOwnProperty.call.bind({}.hasOwnProperty);
/**
 * /**
 * Determines whether an object has a property with the specified name.
 *
 * Safe for use on user-supplied data.
 *
 * @param obj The object that will be checked.
 * @param v A property name.
 * @returns `true` if the object has a property with the specified name,
 * otherwise false.
 */
const hasOwn = (obj, prop) => {
    return obj != null && _hasOwn(obj, prop);
};
exports.hasOwn = hasOwn;
//# sourceMappingURL=has-own.js.map

/***/ }),

/***/ 6718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Heap = void 0;
class Heap {
    /**
     * Creates a priority-queue heap where the highest priority element,
     * as determined by the `less` function, is at the tip/root of the heap.
     * To read the highest priority element without removing it call peek(). To
     * read and remove the element call `shift()`
     * @param less the comparator function
     * @param refresher the refresher function
     */
    constructor(less, refresher) {
        this.length = 0;
        this.array = [];
        this.less = less;
        this.refresher = refresher;
    }
    init(array) {
        this.array = array;
        const length = (this.length = array.length);
        for (let i = ((length / 2) | 0) - 1; i >= 0;) {
            this.down(i--, length);
        }
    }
    /**
     * Updates all entries by calling the Heap's `refresher` function for each
     * item in the heap and then re-sorting.
     * @param context
     */
    /**
     * Updates all entries by calling the Heap's `refresher` function for each
     * item in the heap and then re-sorting.
     * @param context
     */
    refresh(context) {
        const length = this.length;
        const mid = (length / 2) | 0;
        for (let i = mid; i < length; i++) {
            this.refresher(this.array[i], context);
        }
        for (let i = mid - 1; i >= 0;) {
            this.refresher(this.array[i], context);
            this.down(i--, length);
        }
    }
    /**
     * Pushes a new element onto the heap
     * @param value
     */
    push(value) {
        const i = this.length++;
        this.array[i] = value;
        this.up(i);
    }
    size() {
        return this.length;
    }
    /**
     * Return the current best element. Does not remove it
     */
    peek() {
        return this.array[0];
    }
    clear() {
        this.length = this.array.length = 0;
    }
    /**
     * Removes and returns the element with the highest priority from the heap.
     * The complexity is O(log n) where n = this.size().
     * @returns the element with the highest priority. returns `undefined` if
     * there are no more elements in the heap.
     */
    shift() {
        const length = this.length;
        // if we are empty or about to be empty...
        if (length <= 1) {
            if (length === 0)
                return;
            const element = this.array[0];
            // finally, clear the array
            this.clear();
            return element;
        }
        // otherwise...
        // remember the best element
        const array = this.array;
        const best = array[0];
        const newLength = (this.length = length - 1);
        // put our last element at the start of the heap
        array[0] = array[newLength];
        // then sort from the new first element to the second to last element
        this.down(0, newLength);
        return best;
    }
    /**
     * Removes the highest priority element from the queue, replacing it with
     * the new element. This is equivalent to, but faster than, calling
     * `replace(0, newValue);`.
     * If you call this on an empty heap (`this.size() === 0`) you may find
     * unexpected behavior.
     * @param newValue
     */
    replaceBest(newValue) {
        this.array[0] = newValue;
        this.down(0, this.length);
    }
    /**
     * Replaces the element at position `i` with the `newValue`. If the element at
     * position `i` doesn't exist, or if `i < 0` or `i > this.size()` you may
     * find unexpected behavior.
     * @param i
     * @param newValue
     */
    replace(i, newValue) {
        this.array[i] = newValue;
        this.fix(i);
    }
    /**
     * Removes the element at position `i`.
     * The complexity is O(log n) where n = this.size().
     * @param i the element to remove
     */
    remove(i) {
        const newLength = --this.length;
        if (newLength !== i) {
            this.swap(i, newLength);
            if (!this.down(i, newLength)) {
                this.up(i);
            }
        }
    }
    /**
     * Removes the element with the highest priority from the heap
     * The complexity is O(log n) where n = this.size().
     * @returns `true` when there are more elements in the queue, `false` when the
     * last element was just removed. Calling `removeBest` when there are no more
     * elements in the queue will return `true`. So don't do that.
     */
    removeBest() {
        const array = this.array;
        const length = this.length;
        if (length === 1) {
            // finally, clear the array
            this.length = array.length = 0;
            return false;
        }
        const newLength = --this.length;
        // put our last element at the start of the heap
        array[0] = array[newLength];
        // then sort from the new first element to the second to last element
        this.down(0, newLength);
        return true;
    }
    /**
     * Re-establishes the heap ordering after the element at index `i` changes
     * its value. Changing the value of the element at index `i` and then
     * calling fix is equivalent to, but faster than, calling
     * `remove(i); push(newValue);`.
     * The complexity is O(log n) where n = this.size().
     * @param i
     */
    fix(i) {
        if (!this.down(i, this.length)) {
            this.up(i);
        }
    }
    up(j) {
        const less = this.less.bind(null, this.array);
        for (let i; (i = ((j - 1) / 2) | 0), i !== j && less(j, i); j = i) {
            this.swap(i, j);
        }
    }
    down(i0, l) {
        const less = this.less.bind(null, this.array);
        let i = i0;
        for (let j1; (j1 = 2 * i + 1) < l;) {
            let j = j1; // left child
            let j2 = j1 + 1;
            if (j2 < l && less(j2, j1)) {
                j = j2; // = 2 * i + 2  // right child
            }
            if (!less(j, i)) {
                break;
            }
            this.swap(i, j);
            i = j;
        }
        return i > i0;
    }
    /**
     * Swaps the elements in the heap
     * @param i The first element
     * @param j The second element
     */
    swap(i, j) {
        const array = this.array;
        const first = array[i];
        array[i] = array[j];
        array[j] = first;
    }
    /**
     * Heap initialization helper for when you only know of a single item for the
     * heap.
     * @param item
     * @param less
     * @param refresher
     */
    static from(item, less, refresher) {
        const heap = new Heap(less, refresher);
        heap.array = [item];
        heap.length = 1;
        return heap;
    }
}
exports.Heap = Heap;
//# sourceMappingURL=heap.js.map

/***/ }),

/***/ 2875:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(6153), exports);
__exportStar(__webpack_require__(6802), exports);
__exportStar(__webpack_require__(1131), exports);
__exportStar(__webpack_require__(6718), exports);
__exportStar(__webpack_require__(435), exports);
__exportStar(__webpack_require__(9293), exports);
__exportStar(__webpack_require__(149), exports);
__exportStar(__webpack_require__(614), exports);
__exportStar(__webpack_require__(9007), exports);
__exportStar(__webpack_require__(3781), exports);
__exportStar(__webpack_require__(7847), exports);
__exportStar(__webpack_require__(4092), exports);
__exportStar(__webpack_require__(4959), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7847:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak = void 0;
const keccak_1 = __importDefault(__webpack_require__(8112));
const RATE = 1088;
const CAPACITY = 512;
const instance = keccak_1.default("keccak256");
/**
 * keccak256, but faster if you use it a lot.
 * @param buffer
 */
function keccak(buffer) {
    instance._state.absorb(buffer);
    const digest = instance._state.squeeze(32);
    // reset and remove result from memory
    instance._state.initialize(RATE, CAPACITY);
    // make this re-usable
    instance._finalized = false;
    return digest;
}
exports.keccak = keccak;
//# sourceMappingURL=keccak.js.map

/***/ }),

/***/ 4959:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RandomNumberGenerator = void 0;
const seedrandom_1 = __importDefault(__webpack_require__(8330));
class RandomNumberGenerator {
    // I was planning on using `state` here to restore the RNG
    // from a saved state (via the db on run or upon a revert),
    // but this functionality was postponed. I'm keeping the arg
    // here as it still applies and is valid code.
    // https://github.com/trufflesuite/ganache/issues/756
    constructor(seed, state) {
        if (typeof seed === "string" && typeof state === "undefined") {
            this.rng = seedrandom_1.default.alea(seed, { state: true });
        }
        else if (typeof state === "object") {
            // We can ignore seed even if it was provided.
            // The user is reseeding the rng from a prior state,
            // so let's initialize accordingly
            this.rng = seedrandom_1.default.alea("", { state });
        }
        else {
            const entropy = Math.random() * Date.now();
            this.rng = seedrandom_1.default.alea(`${entropy}`, { state: true });
        }
    }
    getNumber(upperExclusiveBound = 1) {
        // I believe this check may be a tiny bit faster than
        // always multiplying by 1
        if (upperExclusiveBound !== 1) {
            return this.rng() * upperExclusiveBound;
        }
        else {
            return this.rng();
        }
    }
    getNumbers(length, upperExclusiveBound = 1) {
        const numbers = [];
        for (let i = 0; i < length; i++) {
            numbers.push(this.getNumber(upperExclusiveBound));
        }
        return numbers;
    }
    getBuffer(length) {
        return Buffer.from(this.getNumbers(length, 256));
    }
    state() {
        return this.rng.state();
    }
}
exports.RandomNumberGenerator = RandomNumberGenerator;
//# sourceMappingURL=random-number-generator.js.map

/***/ }),

/***/ 435:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _paused, _process;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestCoordinator = void 0;
const noop = () => { };
/**
 * Responsible for managing global concurrent requests.
 */
class RequestCoordinator {
    /**
     * Promise-based FIFO queue.
     * @param limit The number of requests that can be processed at a time.
     * Default value is is no limit (`0`).
     */
    constructor(limit) {
        /**
         * The pending requests. You can't do anything with this array.
         */
        this.pending = [];
        /**
         * The number of tasks currently being processed.
         */
        this.runningTasks = 0;
        _paused.set(this, true);
        /**
         * Pause processing. This will *not* cancel any promises that are currently
         * running.
         */
        this.pause = () => {
            __classPrivateFieldSet(this, _paused, true);
        };
        /**
         * Resume processing.
         */
        this.resume = () => {
            __classPrivateFieldSet(this, _paused, false);
            __classPrivateFieldGet(this, _process).call(this);
        };
        _process.set(this, () => {
            // if we aren't paused and the number of things we're processing is under
            // our limit and we have things to process: do it!
            while (!this.paused &&
                this.pending.length > 0 &&
                (!this.limit || this.runningTasks < this.limit)) {
                const current = this.pending.shift();
                this.runningTasks++;
                current()
                    // By now, we've resolved the fn's `value` by sending it to the parent scope.
                    // But over here, we're also waiting for this fn's _value_ to settle _itself_ (it might be a promise) before
                    // continuing through the `pending` queue. Because we wait for it again here, it could potentially throw here,
                    // in which case we just need to catch it and throw the result away. We could probably use
                    // `Promise.allSettled([current()]).finally` to do this instead of the `current().catch(noop).finally`. /shrug
                    .catch(noop)
                    .finally(() => {
                    this.runningTasks--;
                    __classPrivateFieldGet(this, _process).call(this);
                });
            }
        });
        /**
         * Insert a new function into the queue.
         */
        this.queue = (fn, thisArgument, argumentsList) => {
            return new Promise((resolve, reject) => {
                // const executor is `async` to force the return value into a Promise.
                const executor = async () => {
                    try {
                        const value = Reflect.apply(fn, thisArgument, argumentsList || []);
                        resolve({ value });
                        return value;
                    }
                    catch (e) {
                        reject(e);
                    }
                };
                this.pending.push(executor);
                __classPrivateFieldGet(this, _process).call(this);
            });
        };
        this.limit = limit;
    }
    get paused() {
        return __classPrivateFieldGet(this, _paused);
    }
}
exports.RequestCoordinator = RequestCoordinator;
_paused = new WeakMap(), _process = new WeakMap();
//# sourceMappingURL=request-coordinator.js.map

/***/ }),

/***/ 614:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uintToBuffer = void 0;
const MAX_UINT32 = 0xffffffff;
/**
 * This is just Node's `Buffer.allocUnsafe`. I'm documenting it extra here to
 * draw attention to it. It is much faster the `Buffer.alloc(size)` because it
 * doesn't initialize its memory first. It's safe for us to use below because we
 * guarantee that we will fill every octet ourselves.
 *
 * Allocates a new buffer of {size} octets, leaving memory not initialized, so
 * the contents of the newly created Buffer are unknown and may contain
 * sensitive data.
 *
 * @param {number} size count of octets to allocate
 */
const allocUnsafe = Buffer.allocUnsafe;
/**
 * Converts positive whole numbers that are 32 bits of fewer to a Buffer. Any
 * more bits and who knows what will happen!?!1?!
 *
 * @param num A positive whole number less than 33 bits wide, i.e. a uint32.
 * @returns an optimally sized buffer holding `num` in big-endian order (LSB is
 * the _last_ value in the Buffer)
 */
function uint32ToBuf(num) {
    let buf;
    /** `lsb` holds the Least Significant *byte* of `num`. It *technically* holds
     * all of `num`'s bytes but because of how UInt8Arrays (and thus Buffers)
     * work, only the least significant byte of each value gets used. */
    const lsb = num;
    // shift the first 8 least signficant bits off current num, if it's non-zero
    // our value contains at least 2 bytes!
    if ((num >>>= 8)) {
        /** `second` now holds the second most least significant byte in its
         * "first" (right most) 8 bits */
        const second = num;
        // shift the next 8 least signficant bits off current num, if it's non-zero
        // our value contains at least 3 bytes!
        if ((num >>>= 8)) {
            /** `third` now holds the third most least significant byte in its
             * "first" (right most) 8 bits */
            const third = num;
            if ((num >>>= 8)) {
                // since we have all 4 bytes, create a 4 byte Buffer and fill it with
                // our values!
                buf = allocUnsafe(4);
                // `num` here is just what is left after shifting off the 3 other bytes
                // like we did above
                buf[0] = num;
                buf[1] = third;
                buf[2] = second;
                buf[3] = lsb;
            }
            else {
                // since we only have 3 bytes, create a 3 byte Buffer and fill it with
                // our values!
                buf = allocUnsafe(3);
                buf[0] = third;
                buf[1] = second;
                buf[2] = lsb;
            }
        }
        else {
            // since we only have 2 bytes, create a 2 byte Buffer and fill it with
            // our values!
            buf = allocUnsafe(2);
            buf[0] = second;
            buf[1] = lsb;
        }
    }
    else {
        // We only have 1 byte, create a 1 byte Buffer and fill it with our only
        // value, lsb!
        buf = allocUnsafe(1);
        buf[0] = lsb;
    }
    // finally, return our optimally-sized Buffer!
    return buf;
}
/**
 * Converts positive whole numbers less than or equal to
 * `Number.MAX_SAFE_INTEGER` to a Buffer. If your value is less than 2**32 you
 * should use `uint32ToBuf` instead.
 *
 * @param num A positive whole number <= `Number.MAX_SAFE_INTEGER`
 * @returns an optimally sized buffer holding `num` in big-endian order (LSB is
 * the _last_ value in the Buffer)
 */
function uintWideToBuf(num) {
    // This function is similar to `uint32ToBuf`, but splits the number into its
    // 32 lowest bits and its 32 highest bits. We have to do this because numeric
    // Bitwise operations can only operate on 32 bit-wide values.
    // There are some differences, but if you first grasp `uint32ToBuf`, you can
    // handle this just fine.
    let buf;
    /** If we are in this function we are probably > 32 bits wide, so we need to
     * first convert this value to BigInt in order to shift off those high bits.
     * Now that I'm documenting this, we could probably just subtract `2**32` from
     * `num` to avoid the conversion overhead (BigInts are slower than numbers) */
    let hi = Number(BigInt(num) >> 32n);
    const hiLsb = hi;
    let offset = 0;
    // the high bits determine the size of the Buffer, so we compute the high bits
    // first
    if ((hi >>>= 8)) {
        const six = hi;
        if ((hi >>>= 8)) {
            const five = hi;
            if ((hi >>>= 8)) {
                buf = allocUnsafe(8);
                buf[0] = hi; // msb
                buf[1] = five;
                buf[2] = six;
                buf[3] = hiLsb;
                offset = 7;
            }
            else {
                buf = allocUnsafe(7);
                buf[0] = five; // msb
                buf[1] = six;
                buf[2] = hiLsb;
                offset = 6;
            }
        }
        else {
            buf = allocUnsafe(6);
            buf[0] = six; // msb
            buf[1] = hiLsb;
            offset = 5;
        }
    }
    else {
        buf = allocUnsafe(5);
        buf[0] = hiLsb; // msb
        offset = 4;
    }
    // set the low bytes:
    let lo = num & MAX_UINT32;
    const lsb = lo;
    if ((lo >>>= 8)) {
        const two = lo;
        if ((lo >>>= 8)) {
            const one = lo;
            buf[offset - 3] = lo >>>= 8;
            buf[offset - 2] = one;
            buf[offset - 1] = two;
            buf[offset] = lsb;
        }
        else {
            buf[offset - 3] = 0;
            buf[offset - 2] = 0;
            buf[offset - 1] = two;
            buf[offset] = lsb;
        }
    }
    else {
        buf[offset - 3] = 0;
        buf[offset - 2] = 0;
        buf[offset - 1] = 0;
        buf[offset] = lsb;
    }
    return buf;
}
/**
 * Converts a JavaScript number, treated as a Whole Number (0, 1, 2, 3, 4, ...)
 * less than 64 bits wide, to a Buffer.
 *
 * Numbers that are negative, fractional, or greater than 64 bits wide will
 * return very unexpected results. Numbers that are greater than
 * `Number.MAX_SAFE_INTEGER` will return unexpected results.
 *
 * @param num A positive whole number <= `Number.MAX_SAFE_INTEGER`
 */
function uintToBuffer(num) {
    return num > MAX_UINT32 ? uintWideToBuf(num) : uint32ToBuf(num);
}
exports.uintToBuffer = uintToBuffer;
//# sourceMappingURL=uint-to-buffer.js.map

/***/ }),

/***/ 9293:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unref = void 0;
/**
 * In node, calling `unref(timer)` on a running timer ensures that the timer
 * does not require that the Node.js event remain active. If there is no other
 * activity keeping the event loop running, the process may exit before the
 * timer's callback is invoked.
 * @param timer
 * @returns `true` if the timer could be `unref`ed, otherwise returns `false`
 */
function unref(timer) {
    if (typeof timer === "object" && typeof timer.unref === "function") {
        timer.unref();
        return true;
    }
    else {
        return false;
    }
}
exports.unref = unref;
//# sourceMappingURL=unref.js.map

/***/ }),

/***/ 7655:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(5622);
let converter;
{
    try {
        // TODO: add arch-specific binaries as necessary
        converter = __webpack_require__(9144)(path.join(__dirname, `../`));
    }
    catch (e) {
        console.warn('bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)');
    }
}
/**
 * Convert a little-endian buffer into a BigInt.
 * @param buf The little-endian buffer to convert
 * @returns A BigInt with the little-endian representation of buf.
 */
function toBigIntLE(buf) {
    if (converter === undefined) {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
}
exports.toBigIntLE = toBigIntLE;
/**
 * Convert a big-endian buffer into a BigInt
 * @param buf The big-endian buffer to convert.
 * @returns A BigInt with the big-endian representation of buf.
 */
function toBigIntBE(buf) {
    if (converter === undefined) {
        const hex = buf.toString('hex');
        if (hex.length === 0) {
            return BigInt(0);
        }
        return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
}
exports.toBigIntBE = toBigIntBE;
/**
 * Convert a BigInt to a little-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A little-endian buffer representation of num.
 */
function toBufferLE(num, width) {
    if (converter === undefined) {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
        buffer.reverse();
        return buffer;
    }
    // Allocation is done here, since it is slower using napi in C
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
}
exports.toBufferLE = toBufferLE;
/**
 * Convert a BigInt to a big-endian buffer.
 * @param num   The BigInt to convert.
 * @param width The number of bytes that the resulting buffer should be.
 * @returns A big-endian buffer representation of num.
 */
function toBufferBE(num, width) {
    if (converter === undefined) {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
}
exports.toBufferBE = toBufferBE;


/***/ }),

/***/ 9144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(5747)
var path = __webpack_require__(5622)
var os = __webpack_require__(2087)

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : 'node'
var arch = os.arch()
var platform = os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.path(dir))
}

load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    process.versions.electron ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]
    if (!tuple) return

    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', tuple.name)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTuple (name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-')
  if (arr.length !== 2) return

  var platform = arr[0]
  var architectures = arr[1].split('+')

  if (!platform) return
  if (!architectures.length) return
  if (!architectures.every(Boolean)) return

  return { name, platform, architectures }
}

function matchTuple (platform, arch) {
  return function (tuple) {
    if (tuple == null) return false
    if (tuple.platform !== platform) return false
    return tuple.architectures.includes(arch)
  }
}

function compareTuples (a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags
load.parseTuple = parseTuple
load.matchTuple = matchTuple
load.compareTuples = compareTuples


/***/ }),

/***/ 6462:
/***/ ((module) => {

"use strict";


const anyMap = new WeakMap();
const eventsMap = new WeakMap();
const producersMap = new WeakMap();
const anyProducer = Symbol('anyProducer');
const resolvedPromise = Promise.resolve();

const listenerAdded = Symbol('listenerAdded');
const listenerRemoved = Symbol('listenerRemoved');

function assertEventName(eventName) {
	if (typeof eventName !== 'string' && typeof eventName !== 'symbol') {
		throw new TypeError('eventName must be a string or a symbol');
	}
}

function assertListener(listener) {
	if (typeof listener !== 'function') {
		throw new TypeError('listener must be a function');
	}
}

function getListeners(instance, eventName) {
	const events = eventsMap.get(instance);
	if (!events.has(eventName)) {
		events.set(eventName, new Set());
	}

	return events.get(eventName);
}

function getEventProducers(instance, eventName) {
	const key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;
	const producers = producersMap.get(instance);
	if (!producers.has(key)) {
		producers.set(key, new Set());
	}

	return producers.get(key);
}

function enqueueProducers(instance, eventName, eventData) {
	const producers = producersMap.get(instance);
	if (producers.has(eventName)) {
		for (const producer of producers.get(eventName)) {
			producer.enqueue(eventData);
		}
	}

	if (producers.has(anyProducer)) {
		const item = Promise.all([eventName, eventData]);
		for (const producer of producers.get(anyProducer)) {
			producer.enqueue(item);
		}
	}
}

function iterator(instance, eventNames) {
	eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

	let isFinished = false;
	let flush = () => {};
	let queue = [];

	const producer = {
		enqueue(item) {
			queue.push(item);
			flush();
		},
		finish() {
			isFinished = true;
			flush();
		}
	};

	for (const eventName of eventNames) {
		getEventProducers(instance, eventName).add(producer);
	}

	return {
		async next() {
			if (!queue) {
				return {done: true};
			}

			if (queue.length === 0) {
				if (isFinished) {
					queue = undefined;
					return this.next();
				}

				await new Promise(resolve => {
					flush = resolve;
				});

				return this.next();
			}

			return {
				done: false,
				value: await queue.shift()
			};
		},

		async return(value) {
			queue = undefined;

			for (const eventName of eventNames) {
				getEventProducers(instance, eventName).delete(producer);
			}

			flush();

			return arguments.length > 0 ?
				{done: true, value: await value} :
				{done: true};
		},

		[Symbol.asyncIterator]() {
			return this;
		}
	};
}

function defaultMethodNamesOrAssert(methodNames) {
	if (methodNames === undefined) {
		return allEmitteryMethods;
	}

	if (!Array.isArray(methodNames)) {
		throw new TypeError('`methodNames` must be an array of strings');
	}

	for (const methodName of methodNames) {
		if (!allEmitteryMethods.includes(methodName)) {
			if (typeof methodName !== 'string') {
				throw new TypeError('`methodNames` element must be a string');
			}

			throw new Error(`${methodName} is not Emittery method`);
		}
	}

	return methodNames;
}

const isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;

class Emittery {
	static mixin(emitteryPropertyName, methodNames) {
		methodNames = defaultMethodNamesOrAssert(methodNames);
		return target => {
			if (typeof target !== 'function') {
				throw new TypeError('`target` must be function');
			}

			for (const methodName of methodNames) {
				if (target.prototype[methodName] !== undefined) {
					throw new Error(`The property \`${methodName}\` already exists on \`target\``);
				}
			}

			function getEmitteryProperty() {
				Object.defineProperty(this, emitteryPropertyName, {
					enumerable: false,
					value: new Emittery()
				});
				return this[emitteryPropertyName];
			}

			Object.defineProperty(target.prototype, emitteryPropertyName, {
				enumerable: false,
				get: getEmitteryProperty
			});

			const emitteryMethodCaller = methodName => function (...args) {
				return this[emitteryPropertyName][methodName](...args);
			};

			for (const methodName of methodNames) {
				Object.defineProperty(target.prototype, methodName, {
					enumerable: false,
					value: emitteryMethodCaller(methodName)
				});
			}

			return target;
		};
	}

	constructor() {
		anyMap.set(this, new Set());
		eventsMap.set(this, new Map());
		producersMap.set(this, new Map());
	}

	on(eventNames, listener) {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).add(listener);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerAdded, {eventName, listener});
			}
		}

		return this.off.bind(this, eventNames, listener);
	}

	off(eventNames, listener) {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).delete(listener);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerRemoved, {eventName, listener});
			}
		}
	}

	once(eventNames) {
		return new Promise(resolve => {
			const off = this.on(eventNames, data => {
				off();
				resolve(data);
			});
		});
	}

	events(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
		}

		return iterator(this, eventNames);
	}

	async emit(eventName, eventData) {
		assertEventName(eventName);

		enqueueProducers(this, eventName, eventData);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];

		await resolvedPromise;
		await Promise.all([
			...staticListeners.map(async listener => {
				if (listeners.has(listener)) {
					return listener(eventData);
				}
			}),
			...staticAnyListeners.map(async listener => {
				if (anyListeners.has(listener)) {
					return listener(eventName, eventData);
				}
			})
		]);
	}

	async emitSerial(eventName, eventData) {
		assertEventName(eventName);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = [...anyListeners];

		await resolvedPromise;
		/* eslint-disable no-await-in-loop */
		for (const listener of staticListeners) {
			if (listeners.has(listener)) {
				await listener(eventData);
			}
		}

		for (const listener of staticAnyListeners) {
			if (anyListeners.has(listener)) {
				await listener(eventName, eventData);
			}
		}
		/* eslint-enable no-await-in-loop */
	}

	onAny(listener) {
		assertListener(listener);
		anyMap.get(this).add(listener);
		this.emit(listenerAdded, {listener});
		return this.offAny.bind(this, listener);
	}

	anyEvent() {
		return iterator(this);
	}

	offAny(listener) {
		assertListener(listener);
		this.emit(listenerRemoved, {listener});
		anyMap.get(this).delete(listener);
	}

	clearListeners(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

		for (const eventName of eventNames) {
			if (typeof eventName === 'string' || typeof eventName === 'symbol') {
				getListeners(this, eventName).clear();

				const producers = getEventProducers(this, eventName);

				for (const producer of producers) {
					producer.finish();
				}

				producers.clear();
			} else {
				anyMap.get(this).clear();

				for (const listeners of eventsMap.get(this).values()) {
					listeners.clear();
				}

				for (const producers of producersMap.get(this).values()) {
					for (const producer of producers) {
						producer.finish();
					}

					producers.clear();
				}
			}
		}
	}

	listenerCount(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		let count = 0;

		for (const eventName of eventNames) {
			if (typeof eventName === 'string') {
				count += anyMap.get(this).size + getListeners(this, eventName).size +
					getEventProducers(this, eventName).size + getEventProducers(this).size;
				continue;
			}

			if (typeof eventName !== 'undefined') {
				assertEventName(eventName);
			}

			count += anyMap.get(this).size;

			for (const value of eventsMap.get(this).values()) {
				count += value.size;
			}

			for (const value of producersMap.get(this).values()) {
				count += value.size;
			}
		}

		return count;
	}

	bindMethods(target, methodNames) {
		if (typeof target !== 'object' || target === null) {
			throw new TypeError('`target` must be an object');
		}

		methodNames = defaultMethodNamesOrAssert(methodNames);

		for (const methodName of methodNames) {
			if (target[methodName] !== undefined) {
				throw new Error(`The property \`${methodName}\` already exists on \`target\``);
			}

			Object.defineProperty(target, methodName, {
				enumerable: false,
				value: this[methodName].bind(this)
			});
		}
	}
}

const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');

// Subclass used to encourage TS users to type their events.
Emittery.Typed = class extends Emittery {};
Object.defineProperty(Emittery.Typed, 'Typed', {
	enumerable: false,
	value: undefined
});

Object.defineProperty(Emittery, 'listenerAdded', {
	value: listenerAdded,
	writable: false,
	enumerable: true,
	configurable: false
});
Object.defineProperty(Emittery, 'listenerRemoved', {
	value: listenerRemoved,
	writable: false,
	enumerable: true,
	configurable: false
});

module.exports = Emittery;


/***/ }),

/***/ 8330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(3685);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(2107);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(4208);

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(7068);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(3514);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(9492);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(9131);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ 3685:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 9492:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 2107:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 3514:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ }),

/***/ 7068:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ }),

/***/ 4208:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ }),

/***/ 9131:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(6417);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8112:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8112__;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(1416);
/******/ })()
.default;
});
//# sourceMappingURL=ganache-filecoin-options.min.js.map